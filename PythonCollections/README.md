# Коллекции
1. [Проблема](#why)
2. [Что такое коллекция](#collection)
3. [List](#list)
4. [Tuple](#tuple)
5. [Set](#set)
6. [Приведение коллекций](#collection_cast)
7. [Модель данных в Python](#data_model)
8. [Homework](./homework.py)


### <a name='why'>Проблема</a>
- Представим, мы пишем программу, которая позволяет выполнять грузоперевозки по морю. Можем представить ее в следующем виде:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    ```
    Однако, если нужно добавить еще одно именование, нужно будет заводить новые переменные с новыми значениями, кроме того нужно будет писать для этих переменных какой-то код для обработки этих грузов, из-за этого программный код будет разрастаться, а программа перестанет быть универсальной. В этих примерах данные однородны, т.е. для их обработки скорее всего будет использоваться один и тот же способ доставки и оформления.

### <a name="collection"> Что такое коллекции</a>
- Для решения проблем работы с однородными данными, придумали коллекции. Это структура, которая позволяет работать с множеством элементов, как с одним целым.
- Коллекции в Python - это не просто типы, а [структуры данных](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85). Есть множество структур данных, и все они служат для одной цели: представлять множество элементов как одно целое. 

### <a name='list'>List</a>
- В Python есть специальный тип, называемый `list`(ru: список). Можно себе представить `list` как одну сущность, в которую складываются другие сущности, например как контейнер для грузоперевозок:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    # упаковываем в лист, чтобы дальше было проще работать
    cargo_container = [cargo_TV, cargo_phone, cargo_microwave]
    ```
    Теперь мы можем работать со всеми элементами, как с одним целым. Например переправить сразу все элементы, или удалить их.
- Можно группировать старые элементы в список, как мы сделали с уже существующими элементами `cargo` в предыдущем примере, а можно объявлять значения сразу в списке:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    ```
- У списков есть специальный синтаксис для обращения к элементам. У каждого элемента есть специальный номер, при помощи которого к нему можно обратиться. Например в списке `cargo_container` 3 элемента: `"LG v 7", "Samsung 10s", "Samsung ME83X"`, однако **нумерация в списках идет с 0-го** элемента, то есть элемент `"LG v 7"`
 будет иметь индекс(номер) 0. Обращаться к элементу можно через квадратные скобки - `[]`, например, чтобы получить `"LG v 7"` нужно написать:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_TV = cargo_container[0]
    print(cargo_TV) # выведет "LG v 7"
    ```
    Чтобы получить `"Samsung 10s"` - 2-й элемент списка, надо обратиться к нему по индексу `1`:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_phone  = cargo_container[1]
    print(cargo_phone) # выведет "Samsung 10s"
    ```
- Хранить в списке можно не только строки, но и другие типы данных:
    ```python
    cargo_weights = [15, 0.2, 10]
    print(cargo_weights[0]) # выведет 15
    ```
    Можно хранить даже данные разных типов, однако лучше так не делать, так как одинаково обрабатывать данные в последующем будет сложно:
    ```python
    cargo_weights = [15, "0.2", 10]
    print(cargo_weights[1]) # выведет 0.2
    ```
- Хранить в списке можно даже другие списки, например:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_info = [cargo_container, cargo_weights]
    print(cargo_info[0]) # Вывод: ['LG v 7', 'Samsung 10s', 'Samsung ME83X']
    ```
- Итак, инициализацию(объявление) списка можно делать как с готовыми переменными, так и просто со значениями. Как с данными одного типа, так и с данными разных типов. Можно получать даннные из списка. А можно ли его изменять?
- Изменять элемент в списке можно, если обратиться к нему по индексу списка и присвоить туда новое значение:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[0] = 20
    print(cargo_weights) #Вывод:  [20, "0.2", 10]
    ```
    В примере мы изменили первый элемент, перезаписав его, но для элементов списка у нас есть те же операции, что и над простыми переменными данного типа, например:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[0] += 5
    print(cargo_weights) #Вывод:  [20, "0.2", 10]
    ```
    Или же можно вместо строки `"0.2"` положить в элемент числовое значение:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[1] += int(cargo_weights[1])
    print(cargo_weights) #Тип первого элемента("0.2") изменился. Вывод:  [20, 0.2, 10]
    ```
- Кроме того, в уже существующий список можно добавлять новые элементы, для этого служит ключевое слово(метод) `append()`, например в нашей программе перевозок появился новый продукт который нужно перевести в контейнере с телевизором, микроволновкой и телефоном:
    ```Python
    # объявляем контейнер
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_weights = [15, 0.2, 10]
    # добавляем в него еще и наушники
    cargo_container.append("Headphones Sony s11") # добавили наименование
    cargo_weights.append(0.2) # добавили вес
    print(cargo_container) # Вывод: ["LG v 7", "Samsung 10s", "Samsung ME83X", "Headphones Sony s11"], теперь элементов 4, а последний элемент имеет индекс 3
    print(cargo_weights) # Вывод: [15, 0.2, 10, 0.2]
    ```
- Элементы в списках могут повторяться, потому в предыдущем примере, список `[15, 0.2, 10, 0.2]` с двумя одинаковыми значениями - это нормально.
- Над списками можно также проводить операции сложения и умножения:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    new_cargos = ["Headphones Sony s11", "Apple watch 7"]
    cargos = new_cargos + cargo_container
    print(cargos) # Вывод: ['Headphones Sony s11', 'Apple watch 7', 'LG v 7', 'Samsung 10s', 'Samsung ME83X']
    ```
    В списке-результате всех грузов `cargos` сначала будут элементы из списка `new_cargos` а потом элементы из `cargo_container`, потому что в таком порядке мы сказали складывать: `cargos = new_cargos + cargo_container`
- Операция умножения:
    ```python
    clear_list = [0] * 10
    print(clear_list) # Вывод: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    clear_list[0] = 1
    print(clear_list) # Вывод: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ```
- Кроме того, можно элементы и выбрасывать из списка. Метод `pop()` списка позволяет получить и выкинуть из списка последний по индексу элемент в нем, например:
    ```python
    cargo_weights = [15, 0.2, 10]
    wicrowave_weight = cargo_weights.pop()
    print(wicrowave_weight) # Вывод: 10  
    print(cargo_weights) # Вывод: [15, 0.2]
    ```
    Можно выкинуть из списка элемент с конкретным индексом, передав в метод `pop()` индекс ненужного элемента:
    ```python
    cargo_weights = [15, 0.2, 10]
    phone_weight = cargo_weights.pop(1)
    print(phone_weight) # Вывод: 0.2 
    print(cargo_weights) # Вывод: [15, 10]
    ```
- Про распаковку. То, что мы делали в самом начале:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    # упаковываем в лист, чтобы дальше было проще работать
    cargo_container = [cargo_TV, cargo_phone, cargo_microwave]
    ```
    Называется упаковкой элементов в список. Если их можно упаковывать, значит можно и распаковывать:
    ```python
    cargo_TV, cargo_phone, cargo_microwave = cargo_container
    print(cargo_TV) # "LG v 7"
    print(cargo_phone) # "Samsung 10s"
    print(cargo_microwave) # "Samsung ME83X"
    ```
    Таким образом, мы распаковали наш список, и все значения в нем распределили на разные элементы. Причем старый список никуда не делся, мы все еще можем его использовать.
- Обращение к последнему элементу списка. Обращаться к элементу списка можно не только по индексу с 0-го элемента и до последнего, но и в реверсивном порядке: от последнего до первого:
    ```python
    animals = ["dog", "cat", "pigeon"]
    pigeon = animals[-1] # получили последний элемент коллекции: pigeon
    cat = animals[-2] # получили второй с конца элемент: cat
    ```
Списки - это одна из самых популярных структур данных в Python, если умно подходить к их использованию, то они становятся одним из мощнейших инструментов группировки данных. 

### <a name='tuple'> Tuple </a>
- Tuple(ru: кортеж) - еще одна коллекция, по фукнциям похожа на список, однако в отличае от списка, является **неизменяемой**. Объявляется следующим образом:
    ```Python
    departments = ("developing", "sales", "QA")
    ```
    Объявление происходит через круглые скобки, и после объявления, изменить кортеж нельзя. Попытка присвоения другого значения одному из элементов, приведет к ошибке:
    ```Python
    departments = ("developing", "sales", "QA")
    departments[0] = 'management'

    # Ошибка:
    # Traceback (most recent call last):
    #   File "<stdin>", line 1, in <module>
    # TypeError: 'tuple' object does not support item assignment
    ```
- Кортежи, как и списки можно распаковать:
    ```python
    names = ("Vika", "Volha")
    name_vika, name_volha = names
    ```
### <a name='set'>Set</a>
- Set(множество) - коллекция, в которой все элементы должны быть уникальными:
    ```python
    user_ids = {1,2,3}
    ```
    Id пользователей должны быть уникальны, потому, чтобы не писать такие проверки на уникальность, можно отдать эту работу коллекции множество.
- Добавляются элементы с помощью метода  `add()`:
    ```python
    user_ids.add(4)
    print(user_ids) # {1, 2, 3, 4}
    ```
    Но, если попробовать добавить в множество уже существующий элемент:
    ```python
    user_ids.add(3)
    print(user_ids) # {1, 2, 3, 4}
    ```
    То множество не запишет элемент дважды.
- Во множестве элементы не пронумерованы, потому получить доступ к элементу по индексу нельзя:
    ```python
    employees_set = {"developer", 'QA', 'sales'}
    employees_set[0] # так делать нельзя, вызовет ошибку

    # Traceback (most recent call last):
    #     File "<stdin>", line 1, in <module>
    # TypeError: 'set' object is not subscriptable
    ```
- Удалять элементы можно при помощи метода `remove`, этому методу нужно передать в качестве аргумента значение, которое мы хотим удалить из множества:
    ```python
    user_ids.remove(3)
    print(user_ids) # {1, 2, 4}
    employees_set = {"developer", 'QA', 'sales'}
    employees_set.remove('QA')
    print(employees_set) # {"developer", 'sales'}
    ```

### <a name='collection_cast'>Приведение коллекций</a>
- Коллекции можно приводить друг к другу, используя фишки разных коллекций для облегчения работы, например:
    ```python
    users_ids = [1,1,1,2,3,4,5,6,6] # id юзеров должны быть уникальны, программа должна это гарантировать
    users_ids_set = set(users_ids) # здесь мы избавляемся от повторений и получаем множество {1,2,3,4,5,6}
    # однако, превратив список во множество, мы потеряли возможность получать элемент по индексу.
    # для удобной работы с данными можно привести множество обратно к списку
    users_ids = list(users_ids_set) # теперь у нас список уникальных id: [1,2,3,4,5,6]
    # далее, если нам нужно список превратить в неизменяемый кортеж, можно так же привети его к кортежу
    users_ids = tuple(users_ids) # получили неизменяемый кортеж уникальных элементов
    ```
    Действие в предыдущем примере можно было уместить в одну строку:
    ```python
    users_ids = [1,1,1,2,3,4,5,6,6]
    users_ids = tuple(list(set(users_ids))) # получили неизменяемый кортеж уникальных id: (1,2,3,4,5,6)
    ```
- Получение количества элементов любой коллекции. Для получения количества элементов коллекции, используется функция `len()`:
    ```python
    employees = ["Alex", "Siarhey", "Hanna"]
    employees_number = len(employees) # 3 сотрудника
    users_ids = {1,2,3}
    ids_number = len(users_ids) # 3 уникальных id
    ```

### <a name='data_model'>Модель данных Python</a>
- Python - это язык со ссылочной моделью данных. Это значит, что все в Python - это ссылка. Занося значение в переменную, мы, на самом деле, заносим в эту переменную ссылку на это значение. Проще всего это представить как коробу(какое-то значение) и наклейку на эту коробку(переменная). Наклеек может быть много, а коробка будет одна.
- Встроенная функция `id()` возвращает адрес значения в памяти, например:
    ```python
    count = 5
    print(id(count)) # 9785024
    numb = 5
    print(id(numb)) # 9785024
    numb += 1
    print(id(numb)) # 9785056
    ```
    Предыдущий пример показывает, что на одни и те же значения указывают одни и те же ссылки(у них одни и те же адреса в памяти). Это особенность базовых типов(int, float, str, bool), для них в памяти уже зарезервированы места, потому ссылки на них будут одни и те же в контексте одной программы.
- Однако, всю суть ссылочных моделей видно с более сложными типами данных, например, коллекциями:
    ```python
    employees = ["Alex", "Nika", "Dora"]
    print(id(employees)) # 140608816168640

    people = ["Alex", "Nika", "Dora"]
    print(id(people)) # 140608816133568
    ```
    Значения в переменных абсолютно равны. Однако, в данном случае переменные, указывающие на одни и те же значения в памяти, имеют разные адреса. Это все происходит потому, что для сложных структур данных, типа коллекций, каждый раз **при инициализации** создается новое значение в памяти.
- Но ссылочная модель все еще работает. Перепишем предыдущий пример иначе:
    ```python
    employees = ["Alex", "Nika", "Dora"]
    print(id(employees)) # 140608816168640

    people = employees
    print(id(people)) # 140608816168640
    ```
    Теперь переменные указывают на одно и то же место в памяти. Почему так? Потому что список `people` не был повторно инициализирован, как в предыдущем примере. Инициализация списка происходит при помощи квадратных скобок: `[]`.
- Попробуем поменять значения списка `people`:
    ```python
    employees = ["Alex", "Nika", "Dora"]
    people = employees

    people[0] = "Vika"

    print(people) # ['Vika', 'Nika', 'Dora']
    print(employees) # ['Vika', 'Nika', 'Dora']
    ```
    При изменении списка `people`, так же поменялся и список `employees`, потому что две эти переменны указывают на одни и те же данные в памяти. Незнание этой особенности языка, может допустить множество логических ошибок, при написании кода, когда значения, которые вроде как не должны были меняться, имеют совершенно другие значения, чем ожидалось.
- Для того, чтобы избежать такой проблемы связанных с сылочной моделью, необходимо создавать новые коллекции на основе уже существующих, делается это с помощью функции `list`, как и в приведении типов:
    ```python
    employees = ["Alex", "Nika", "Dora"]
    people = list(employees) # инициализировали новый список, на основе существующего

    print(id(employees)) # 140608805220672
    print(id(people)) # 140608804748160

    people[0] = "Vika"

    print(people) # ['Vika', 'Nika', 'Dora']
    print(employees) # ['Alex', 'Nika', 'Dora']
    ```
    При инициализации на основе уже существующего списка, адреса, находящиеся в переменных, стали разными. Кроме того, изменения списка `people` не повлияли на список `employees`.
- (extra) Так же стоит быть осторожными в случае объявления списка списков с уже заготовленными значениями, которые в течении программы могут меняться. Чаще всего это делается через умножение. Но у этого есть последствия. Например:
    ```python
    matrix = [[0]] * 10
    print(matrix) # [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]
    matrix[0][0] = 1 # Поменяем значение первого столбца, первой строки
    print(matrix) # [[1], [1], [1], [1], [1], [1], [1], [1], [1], [1]]
    ```
    В данном случае опять же работает ссылочная модель, потому что `[[0]]` - уже проинициализированный список, и, умножая его на `10`, мы просто десять раз повторяем ссылку на одно и то же место в памяти. Правильный путь инициализировать список списков в данном случае, это использовать [List Comprehension](https://www.programiz.com/python-programming/list-comprehension).