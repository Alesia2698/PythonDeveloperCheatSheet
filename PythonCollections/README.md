# Коллекции
1. [Проблема](#why)
2. [Что такое коллекция](#collection)
3. [List](#list)
4. [Tuple](#tuple)
5. [Set](#set)
6. [Приведение коллекций](#collection_cast)
7. [Модель данных в Python](#data_model)
8. [Homework](./homework.py)


### <a name='why'>Проблема</a>
- Представим, мы пишем программу, которая позволяет выполнять грузоперевозки по морю. Можем предствить ее в слующем виде:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    ```
    Однако, если нужно добавить еще одно именование, нужно будет заводить новые переменные с новыми значениями, кроме того нужно будет писать для этих переменных какой-то код для обработки этих грузов, из-за этого программный код будет разрастаться, а программа перестанет быть универсальной. В этих примерах данные однородны, т.е. для их обработки скорее всего будет использоваться один и тот же способ доставки и оформления.

### <a name="collection"> Что такое коллекции</a>
- Для решения проблем работы с однородными данными, придумали коллекции. Это структура, которая позволяет работать с множеством элементов, как с одним целым.
- Коллекции в Python - это не просто типы, а [структуры данных](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85). Есть множество структур данных, и все они служат для одной цели: представлять множество элементов как одно целое. 

### <a name='list'>List</a>
- В Python есть специальный тип, называемый `list`(ru: список). Можно себе представить `list` как одну сущность, в которую складываются другие сущности, например как контейнер для грузоперевозок:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    # упаковываем в лист, чтобы дальше было проще работать
    cargo_container = [cargo_TV, cargo_phone, cargo_microwave]
    ```
    Теперь мы можем работать со всеми элементами, как с одним целым. Например переправить сразу все элементы, или удалить их.
- Можно группировать старые элементы в список, как мы сделали с уже существующими элементами `cargo` в предыдущем примере, а можно объявлять значения сразу в списке:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    ```
- У списков есть специальный синтаксис для обращения к элементам. У каждого элемента есть специальный номер, при помощи которого к нему можно обратиться. Например в списке `cargo_container` 3 элемента: `"LG v 7", "Samsung 10s", "Samsung ME83X"`, однако **нумерация в списках идет с 0-го** элемента, то есть элемент `"LG v 7"`
 будет иметь индекс(номер) 0. Обращаться к элементу можно через квадратные скобки - `[]`, например, чтобы получить `"LG v 7"` нужно написать:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_TV = cargo_container[0]
    print(cargo_TV) # выведет "LG v 7"
    ```
    Чтобы получить `"Samsung 10s"` - 2-й элемент списка, надо обратиться к нему по индексу `1`:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_phone  = cargo_container[1]
    print(cargo_phone) # выведет "Samsung 10s"
    ```
- Хранить в списке можно не только строки, но и другие типы данных:
    ```python
    cargo_weights = [15, 0.2, 10]
    print(cargo_weights[0]) # выведет 15
    ```
    Можно хранить даже данные разных типов, однако лучше так не делать, так как одинаково обрабатывать данные в последующем будет сложно:
    ```python
    cargo_weights = [15, "0.2", 10]
    print(cargo_weights[1]) # выведет 0.2
    ```
- Хранить в списке можно даже другие списки, например:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_info = [cargo_container, cargo_weights]
    print(cargo_info[0]) # Вывод: ['LG v 7', 'Samsung 10s', 'Samsung ME83X']
    ```
- Итак, инициализацию(объявление) списка можно делать как с готовыми переменными, так и просто со значениями. Как с данными одного типа, так и с данными разных типов. Можно получать даннные из списка. А можно ли его изменять?
- Изменять элемент в списке можно, если обратиться к нему по индексу списка и присвоить туда новое значение:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[0] = 20
    print(cargo_weights) #Вывод:  [20, "0.2", 10]
    ```
    В примере мы изменили первый элемент, перезаписав его, но для элементов списка у нас есть те же операции, что и над простыми переменными данного типа, например:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[0] += 5
    print(cargo_weights) #Вывод:  [20, "0.2", 10]
    ```
    Или же можно вместо строки `"0.2"` положить в элемент числовое значение:
    ```python
    cargo_weights = [15, "0.2", 10]
    cargo_weights[1] += int(cargo_weights[1])
    print(cargo_weights) #Тип первого элемента("0.2") изменился. Вывод:  [20, 0.2, 10]
    ```
- Кроме того, в уже существующий список можно добавлять новые элементы, для этого служит ключевое слово(метод) `append()`, например в нашей программе перевозок появился новый продукт который нужно перевести в контейнере с телевизором, микроволновкой и телефоном:
    ```Python
    # объявляем контейнер
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    cargo_weights = [15, 0.2, 10]
    # добавляем в него еще и наушники
    cargo_container.append("Headphones Sony s11") # добавили наименование
    cargo_weights.append(0.2) # добавили вес
    print(cargo_container) # Вывод: ["LG v 7", "Samsung 10s", "Samsung ME83X", "Headphones Sony s11"], теперь элементов 4, а последний элемент имеет индекс 3
    print(cargo_weights) # Вывод: [15, 0.2, 10, 0.2]
    ```
- Элементы в списках могут повторяться, потому в предыдущем примере, список `[15, 0.2, 10, 0.2]` с двумя одинаковыми значениями - это нормально.
- Над списками можно также проводить операции сложения и умножения:
    ```python
    cargo_container = ["LG v 7", "Samsung 10s", "Samsung ME83X"]
    new_cargos = ["Headphones Sony s11", "Apple watch 7"]
    cargos = new_cargos + cargo_container
    print(cargos) # Вывод: ['Headphones Sony s11', 'Apple watch 7', 'LG v 7', 'Samsung 10s', 'Samsung ME83X']
    ```
    В списке-результате всех грузов `cargos` сначала будут элементы из списка `new_cargos` а потом элементы из `cargo_container`, потому что в таком порядке мы сказали складывать: `cargos = new_cargos + cargo_container`
- Операция умножения:
    ```python
    clear_list = [0] * 10
    print(clear_list) # Вывод: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    clear_list[0] = 1
    print(clear_list) # Вывод: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ```
- Кроме того, можно элементы и выбрасывать из списка. Метод `pop()` списка позволяет получить и выкинуть из списка последний по индексу элемент в нем, например:
    ```python
    cargo_weights = [15, 0.2, 10]
    wicrowave_weight = cargo_weights.pop()
    print(wicrowave_weight) # Вывод: 10  
    print(cargo_weights) # Вывод: [15, 0.2]
    ```
    Можно выкинуть из списка элемент с конкретным индексом, передав в метод `pop()` индекс ненужного элемента:
    ```python
    cargo_weights = [15, 0.2, 10]
    phone_weight = cargo_weights.pop(1)
    print(phone_weight) # Вывод: 0.2 
    print(cargo_weights) # Вывод: [15, 10]
    ```
- Про распаковку. То, что мы делали в самом начале:
    ```python
    cargo_TV = "LG v 7"
    cargo_phone = "Samsung 10s"
    cargo_microwave = "Samsung ME83X"
    # упаковываем в лист, чтобы дальше было проще работать
    cargo_container = [cargo_TV, cargo_phone, cargo_microwave]
    ```
    Называется упаковкой элементов в список. Если их можно упаковывать, значит можно и распаковывать:
    ```python
    cargo_TV, cargo_phone, cargo_microwave = cargo_container
    print(cargo_TV) # "LG v 7"
    print(cargo_phone) # "Samsung 10s"
    print(cargo_microwave) # "Samsung ME83X"
    ```
    Таким образом, мы распаковали наш список, и все значения в нем распределили на разные элементы. Причем старый список никуда не делся, мы все еще можем его использовать.
- Обращение к последнему элементу списка. Обращаться к элемнту списка можно не только по индексу с 0-го элемента и до последнего, но и в реверсивном порядке: от последнего до первого:
    ```python
    animals = ["dog", "cat", "pigeon"]
    pigeon = animals[-1] # получили последний элемент коллекции: pigeon
    cat = animals[-2] # получили второй с конца элемент: cat
    ```
Списки - это одна из самых популярных структур данных в Python, если умно подходить к их использованию, то они становятся одним из мощнейших инструментов группировки данных. 

### <a name='tuple'> Tuple </a>
- Tuple(ru: кортеж) - еще одна коллекция, по фукнциям похожа на список, однако в отличае от списка, является **неизменяемой**. Объявляется следующим образом:
    ```Python
    departments = ("developing", "sales", "QA")
    ```
    Объявление происходит через круглые скобки, и после объявления, изменить кортеж нельзя. Попытка присвоения другого значения одному из элементов, приведет к ошибке:
    ```Python
    departments = ("developing", "sales", "QA")
    departments[0] = 'management'

    # Ошибка:
    # Traceback (most recent call last):
    #   File "<stdin>", line 1, in <module>
    # TypeError: 'tuple' object does not support item assignment
    ```
- Кортежи, как и списки можно распаковать:
    ```python
    names = ("Vika", "Volha")
    name_vika, name_volha = names
    ```
### <a name='set'>Set</a>
- Set(множество) - коллекция, в которой все элементы должны быть уникальными:
    ```python
    user_ids = {1,2,3}
    ```
    Id пользователь должны быть уникальны, потому, чтобы не писать такие проверки на уникальность, можно отдать эту работу коллекции множество.
- Добавляются элементы с помощью метода  `add()`:
    ```python
    user_ids.add(4)
    print(user_ids) # {1, 2, 3, 4}
    ```
    Но, если попробовать добавить в множество уже существующий елемент:
    ```python
    user_ids.add(3)
    print(user_ids) # {1, 2, 3, 4}
    ```
    То множество не запишет элемент дважды.
- Во множестве элементы не пронумерованы, потому получить доступ к элементу по индексу нельзя:
    ```python
    employees_set = {"developer", 'QA', 'sales'}
    employees_set[0] # так делать нельзя, вызовет ошибку

    # Traceback (most recent call last):
    #     File "<stdin>", line 1, in <module>
    # TypeError: 'set' object is not subscriptable
    ```
- Удалять элементы можно при помощи метода `remove`, этому методу нужно передать в качестве аргумента значение, которое мы хотим удалить из множества:
    ```python
    user_ids.remove(3)
    print(user_ids) # {1, 2, 4}
    employees_set = {"developer", 'QA', 'sales'}
    employees_set.remove('QA')
    print(employees_set) # {"developer", 'sales'}
    ```

### <a name='collection_cast'>Приведение коллекций</a>
- Коллекции можно приводить друг к другу, используя фишки разных коллекций для облегчения работы, например:
    ```python
    users_ids = [1,1,1,2,3,4,5,6,6] # id юзеров должны быть уникальны, программа должна это гарантировать
    users_ids_set = set(users_ids) # здесь мы избавляемся от повторений и получаем множество {1,2,3,4,5,6}
    # однако превратив список во множество мы потеряли возможность получать элемент по индексу.
    # для удоной работы с данными можно привести множество обратно к списку
    users_ids = list(users_ids_set) # теперь у нис список уникальных id: [1,2,3,4,5,6]
    # далее, если нам нужно список превратить в неизменяемый кортеж, можно так же привети его к кортежу
    users_ids = tuple(users_ids) # получили неизменяемый кортеж уникальных элементов
    ```
    Действие в предыдущем примере можно было уместить в одну строку:
    ```python
    users_ids = [1,1,1,2,3,4,5,6,6]
    users_ids = tuple(list(set(users_ids))) # получили неизменяемый кортеж уникальных id: (1,2,3,4,5,6)
    ```
- Получение количества элементов любой коллекции. Для получения количества элементов коллекции, используется функция `len()`:
    ```python
    employees = ["Alex", "Siarhey", "Hanna"]
    employees_number = len(employees) # 3 сотрудника
    users_ids = {1,2,3}
    ids_number = len(users_ids) # 3 уникальных id
    ```

### <a name='data_model'>Модель данных Python</a>
- все будет но не сразу...)