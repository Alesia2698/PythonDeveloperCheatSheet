# Функции в Python
1. [Функции и аргументы, область видимости](#functions)

### <a name='functions'>Функции и аргументы, область видимости</a>
- Функция - это исполняемый фрагмент кода, который можно переиспользовать множество раз. Функции возвращают какое-либо значение. Синтаксис функции начинается с ключевого слова `def`, после идет название функции, потом в скобках список аргументов, две точки и на следующей строке с отступом сам код функции. Функция возвращает значение при помощи ключевого слова `return`:
    ```python
    def find_lists_intersection(first_list, second_list):
        """Функция для нахождения элементов, которые есть
        и в первом и во втором списках. Возвращает список
        общих элементов.
        """
        intersection = list() # инициализируем пустой список для общих элементов
        for i in first_list: # проходимся по всем элементам первого списка
            if i in second_list: # если элемент есть во втором списке
                intersection.append(i) # то добавляем его в пересечение
        return intersection # возвращаем список общих элементов
    ```
    Данная функция находит общие элементы из двух списков(пересечение) и возвращает новый список. Вызывается она следующим образом:
    ```python
    list_intersect = find_lists_intersection([1, 2, 3, 3], [2, 3, 3, 4])
    print(list_intersect) # [2,3,3]
    ```
    Для вызова функции сначала пишется ее имя, потом передается список аргументов(в нашем случае это [1, 2, 3, 3], [2, 3, 3, 4]) в круглых скобках, количество передаваемых аргументов должно быть равно количеству аргументов при объявлении функции.
    Функции позволяют нам писать код только один раз и переиспользовать его множество раз, например можно найти пересечение сразу 4х списков при помощи уже написанной логики:
    ```python
    list_1 = [1,2,3,4,5,6,7,8]
    list_2 = [3,4,5,6,7,8,9,0]
    list_3 = [5,6,7,5,5,5,6,7]
    list_4 = [1,2,3,5,7,8,9,5]

    list_12_intersect = find_lists_intersection(list_1, list_2) # [3, 4, 5, 6, 7, 8]
    list_34_intersect = find_lists_intersection(list_3, list_4) # [5, 7, 5, 5, 5, 7]

    intersect = find_lists_intersection(
        list_12_intersect, list_34_intersect
    )

    print(intersect) # [5, 7]
    ```
    Функция, при ее вызове возвращает какое-либо значение, как только мы вызвали функцию с переданными ей аргументами(как тут `find_lists_intersection(list_1, list_2)`), она уже перестает быть функцией и становится значением(в нашем случае она превращается в список), зная это, мы можем переписать предыдущий код:
    ```python
    list_1 = [1,2,3,4,5,6,7,8]
    list_2 = [3,4,5,6,7,8,9,0]
    list_3 = [5,6,7,5,5,5,6,7]
    list_4 = [1,2,3,5,7,8,9,5]

    print(find_lists_intersection(
        find_lists_intersection(list_1, list_2), # здесь у нас уже значение [3, 4, 5, 6, 7, 8]
        find_lists_intersection(list_3, list_4) # и тут тоже уже значение [5, 7, 5, 5, 5, 7]
    )) # [5, 7]
    ```
- Для удобства чтения, к аргументам в функциях стараются добавлять аннотации, а также возвращаемое значение, например:
    ```python
    # добавили аннотации типов, а также тип возвращаемого значения
    def find_sum(a: int, b: int) -> int:
        return a + b
    ```
    Так же можно переписать и функцию по нахождению пересечения 2х листов:
    ```python
    from typing import List

    def find_lists_intersection(first_list: List[any], second_list: List[any]) -> List[any]:
        """Функция для нахождения элементов, которые есть
        и в первом и во втором списках. Возвращает список
        общих элементов.
        """
        intersection = list()
        for i in first_list:
            if i in second_list:
                intersection.append(i)
        return intersection
    ```
    В нашем примере аргументами являются коллекции, для их аннотации используются специальные типы из модуля `typing`. Так как список может содержать элементы любого типа, то указывается `List[any]`, если бы функция принимала только списки целых чисел, то указали бы `List[int]`, если бы списки строк, то List[str].
    В модуле `typing` есть множество различных аннотаций, их нужно подбирать по случаю и лучше пользоваться [документацией](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html) или гуглить. В версиях python старше 3.8, типы `list`, `tuple`, `set`, `dict` можно указывать без использования модуля `typing`, то есть писать просто `list[int]`(с маленькой буквы) в старших версиях можно, однако в младших версиях это приведет к ошибке.
- Аргументы в функцию можно передавать так как мы передавали и раньше:
    ```python
    find_lists_intersection([1, 2, 3],[1, "2", 3])
    ```
    а можно, используя именованные аргументы, то есть сразу при передачи указывать названия аргументов, которые мы передали:
    ```python
    def find_lists_intersection(first_list: List[any], second_list: List[any]) -> List[any]:
        ...
    
    find_lists_intersection([1, 2, 3],[1, "2", 3])

    find_lists_intersection(first_list=[1, 2, 3],second_list=[1, "2", 3])

    find_lists_intersection(second_list=[1, "2", 3], first_list=[1, 2, 3])
    ```
    Эти 3 вызова функции абсолютно одинаковы, в первом случае мы просто передали значения, во втором указали их имена, а в третьем сначала передали первый список, а потом второй. Работать с именованными аргументами намного удобнее чем без них, так как разработчик сразу видит, что он передал в функцию. Часто названия аргументов говорят о них больше, чем документация, например именованный аргумент `sep` в процедуре `print()`, из его названия следует что мы передаем разделитель(separator).
- Давайте напишем еще одну небольшую функцию, она должна принимать 2 значения, ставить между ними какой-то разделитель и возвращать одну строку, где 2 значения разделены разделителем:
    ```python
    def separate_values(first_value: any, second_value: any, separator: any) -> str:
        return f"{first_value}{separator}{second_value}"

    string_1 = separate_values(1,2,", ") # "1, 2"
    string_2 = separate_values(separator="!!!", first_value=2, second_value=1) # "2!!!1"
    string_3 = separate_values(1,2) # ошибка!
    string_3 = separate_values(first_value=2, second_value=1) # ошибка!
    ```
    Первые два вызова функции корректны, однако два других вызовут ошибку, потому что мы не передали значение аргумента `separator`. Однако было бы неплохо, если бы, например, по умолчанию проставлялся какой-то `separator`, например `", "`, как в процедуре `print()`. Для таких целей существуют аргументы по умолчанию, задаются они прямо в объявлении функции, в виде присвоения:
    ```python
    def separate_values(
        first_value: any,
        second_value: any,
        separator: any = ", ") -> str:

        return f"{first_value}{separator}{second_value}"

        string_3 = separate_values(1,2) # "1, 2"
        string_3 = separate_values(first_value=2, second_value=1) # "1, 2"
    ```