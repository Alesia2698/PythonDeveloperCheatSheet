# Введение в Python
1. [О Python в целом](#python_general)
2. [Среда исполнения(virlualenv)](#environment)
3. [Типы данных и операции](#data_types)
4. [Homework](./homework.py)

### <a name="python_general">О Python в целом</a>
- **Python** - высокоуровневый(работает с абстракциями, к железу имеет мало отношения) язык программирования общего назначения(не специализируется на какой-то одной задаче, как например регулярные выражения или SQL).
- Python является **интерпретируемым** языком. Это значит, что у программ, написанных на Python, отсуствует стадия **компиляции**(они не переводятся в машинный код или байт-код и не хранятся в бинарном файле). Программы Python выполняются специальной машиной, называемой **интерпретатор**. Самый популярный интерпретатор для Python - это **CPython**(не путать с Cython), отличается от других тем, что во время интерпретирования код на Python считывается и транслируется в язык C. Кроме CPython, есть и другие интерпретароры:
    - CPython - трансляция в C
    - IronPython - трансляция в C#
    - Jython - трансляция в Java
    - PyPy - трансляция в язык R(самая быстрая реализация Python-интерпретатора на данный момент)
  
  </br>
  Каждый интерпретатор написанный на определенной платформе, позволяет использовать в Python-коде все возможности этой платформы, например CPython позволяет использовать C-библиотека, а Jython позволяет использовать библиотеки платформы JVM(Java, Scala, Kotlin)
- Из-за того, что Python интерпретируемый, его **скорость значительно ниже**, чем у компилируемых языков(например Go и C++) и ниже, чем у компилируемо-интерпретируемых языков(Java, Scala, Kotlin, C#). Однако, Python актуален из-за скорости написания программ на нем.

### <a name="environment">Среда исполнения(virlualenv)</a>
- Библиотека - в программировании, это готовое решение, которое можно использовать в своем коде, для использования библиотек есть команда `import`, например довольно часто в коде приходится работать с датами, конечно можно каждый раз писать новый код для дат(код перевода в американскую систему, в европейскую, UTC), однако можно просто воспользоваться готовым решением, которое сразу поставляется с интерпретатором Python:
    ```Python
    import datetime

    current_date = datetime.date.today() # получите нынешнюю дату

    current_date_string = current_date.strftime("%Y-%m-%d") # получите нынешнюю дату в формате строки, например '2022-04-12'
    ```
- Есть библиотеки **предустановленные**, например datetime, они поставляются с интерпретатором Python, а есть библиотеки, которые нужно устанавливать(сторонние), если вы хотите их использовать. Обусловленно это тем, что, например, даты используются в коде часто, и потому они с большой вероятностью понадобятся и их кладут поближе к интерпретатору, однако библиотека для морфологического разбора слов ntlk вряд ли понадобится каждому программисту Python, потому для ее использования, ее нужно **установить**.
- Для установки библиотек используется менеждер зависимостей `pip`, по сути это удобный инструмент с несколькими командами, который контролирует зависимости(установленные библиотеки) в вашем проекте. Его тоже нужно установить, как это сделать, можно посмотреть тут(https://pythonru.com/baza-znanij/ustanovka-pip-dlja-python-i-bazovye-komandy) или погуглить =)
- Устанавливаются сторонние библиотеки следующей командой:
    ```shell
    $> pip install nltk
    ```

  Данный пример показывает установку последней версии nltk, чтобы проверить установилась ли зависимость, можно в этом же окне терминала зайти в интерпретатор Python и импортировать модуль nltk:
  ```python
    $> python
    >>> import nltk
  ```
  Если зависимость установилась корректно, но ничего не должно появиться, если же возникла ошибка установки и модуль не был установлен, то появися следующее сообщение при импорте:
  ```
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ModuleNotFoundError: No module named 'nltk'
  ```
  Для удаления зависимости используется команда `pip uninstall`, например:
  ```shell
  $> pip uninstall nltk
  ```
- Однако, существует проблема разных версий зависимостей. Например, вы работаете в 2х проектах, 1-й - это чат с виртуальным помощником, 2-й - поисковик. Поисковик начали писать давно, чат-бот с помощником - проект новый, оба приложения базируются на анализе введенной фразы, их алгоритмы построены так, что они получают предложения, разбивают их на слова(токены), находят их исходную форму и дальше каждый анализирует их по-своему. Как мы знаем, за анализ слов, нахождения их исходной формы отвечает модуль nltk, однако в поисковике используется старая версия(например 3.0.0) nltk, у нее совсем другой API(https://ru.wikipedia.org/wiki/API), чем у последней версии, которая используется в чат-боте. И вы устанавливаете в своей системе оба модуля nltk(2.0.2 и последнюю):
  ```shell
  $> pip install nltk==3.0.0 #установит конкретную версию
  $> pip install nltk #установит последнюю версию
  ```
  Однако, интерпретатор Python не разбирается в вашем проекте. Он импортирует всегда **только самую последнюю версию** зависимости, из-за этого ваш проект поисковика сломается, вы его запустить не сможете. Как решать такую проблему, если на уровне интерпретатора нет возможности управлять версиями зависимостей? 
- **Виртуальное окружение** - это интерпретатор, и все библиотеки языка с определенными версиями. Запуская новое виртуальное окружение, вы запускаете новый интерпретатор Python в среде, изолированной от вашей основной системе. Проще говоря, это песочница, в которой вы отделены от внешнего мира. В этой среде вы можете устанавливать любую зависимость, которая вам нужна в этом конкретном проекте. Например, для чат-бота будет окружение с последними версиями библиотек, а в поисковике, будет среда с версиями, которые вам нужны только для этого проекта. Работая над поисковиком, вы активируете среду для этого приложения, захотели поработать над чат-ботом, деактивировали среду для поисковика, и активировали окружение для чат-бота.
- Самое популярное средство виртуализации окружения в Python - это **virtualenv** - это инструмент, который позволяет активировать и деактивировать ваше виртуальное окружение. Установка менеждера окружения делается через pip:
    ```shell
        $> pip install virtualenv
    ```
  Далее в консоле, в папке проекта, пишется:
  ```shell
    $> python -m venv env
  ```
  После этой команды в папке появится дирректория `env/`, в ней будет отдельный интерпретатор Python и все зависимости, которые вы установите. Однако пока вы не активировали данное окружение, все ваши зависимости будут устанавливаться в систему. Для активации, вы должны находиться в дирректории, в которой находится папка `env/`:
  ```shell
    $> source ./env/bin/activate # MacOs/Linux
    $> .\env\Scripts\activate # Windows
  ```
  После этого в консоли, перед путем в папку появится маркер `(env)`, это будет готоворить вам о том, что вы в виртуальном окружении.
  Теперь любая ваши зависимость, которая установлена в данном окружении, будет независима от системы.
- Для деактивации используется команда `deactivate`, ее просто можно написать в терминале и все:
    ```shell
    $> deactivate
    ```
  Теперь вы снова в окружении системы, а все зависимости упакованы в вашем деактивированном окружении.

### <a name="data_types"> </a> Типы данных и операции
- Объявление переменных происходит следующим образом:
    ```Python
        count = 0 # число
        name = "Bob" # строка
        size = 12.9 # десятичное число
        is_active = True # булевая переменная(с большой буквы)
    ```
- Название переменной - это то, как вы можете обращаться к значению в данной переменной, например:
    ```Python
    students_number = 13
    teachers_number = 1
    people_number = students_number + teachers_number
    ```
- Python - это язык с **динамической сильной** типизацией. Что это значит?
- Динамическая типизация(https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) - Python не смотрит на типы. Его философия типов называется "утиной": если что-то плавает как утка, квакает как утра, то это утка(противоположность утиной - гусиная типизация, когда важно "видовая"(классовая) принадлежность). Проще говоря, интерпретатору Python не нужно знать типы переменных, он сам под них подстраивается, единственное, что ему нужно, это чтобы эти типы имели одинаковые названия методов("квакали как утка"). Обычно в статических языках необходимо специфицировать переменную, в которой лежит какое-то значение, например Java:
    ```Java
        int count = 1
    ```
  После такого объявления в переменную нельзя ничего положить, кроме числовых значений, например написать `count = 'one'` уже не получится: это вызовет ошшибку компиляции. Однако в Python такое возможно:
  ```Python
  count = 1 # объявили переменную, в которую положили число
  count = 'one' # положили в эту же переменную строку, и все нормально
  ```
+ Сильная типизация(https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B8_%D1%81%D0%BB%D0%B0%D0%B1%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) - значит, что нельзя проводить операции над значениями разных типов, проще говоря нельзя сложить строку с числом:
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = students_number + teachers_number
    ```
  Пример выше вызовет ошибку `TypeError: unsupported operand type(s) for +: 'int' and 'str'`, потому что `students_number` - типа **int**, а `teachers_number` - типа **str**, для исправления данной ошибки нужно сказать интерпретатору, что мы хотим иметь дело с int типом, этот прием называется приведением типов:
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = students_number + int(teachers_number) # привели тип! Получили 14 в ответе
    ```
  Точно так же можно привести int к str:
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = str(students_number) + teachers_number # привели тип! Получили "131" в ответе
    ```
- Операции над числами:
    ```Python
    5 + 3 # сложение, результат 8
    5 - 3 # разность, результат 2
    5 * 3 # умножение, результат 15
    5 ** 3 # возведение в степень, результат 125
    5 / 3 # деление, результат 1.6666666666666667
    5 // 3 # целочисленное деление, результат 1
    5 % 3 # взятие остатка, результат 2
    ```
- Операции над строками:
    ```Python
    "a" + "b" # конкатенация, результат "ab"
    "a" * 10 # можно делать так, результат "aaaaaaaaaa"
    ```
- Операции над логическими переменными:
    ```Python
    True and False # логическиое "и", результат False
    True or False # логическое "или", результат True
    not True # логические "не", результат False
    ```
- (*extra*) Побитовые операции - операции  над представлением значений в битах, можно сдвинуть бит влево(умножить на 2), сдвинуть вправо (отнять один бит), коньюнкция над битами и дизъюнкция над битами:
    ```Python
    4 | 6 # битовое или, результат 6
    4 & 6 # битовое и, результат 4
    4 << 6 # битовый сдвиг влево, результат 256
    4 >> 6 # битовый сдвиг вправо, результат 0
    4 ^ 6 # xor, результат 2
    ```
- Аннотации типов. Иногда удобно проставлять, с каким типом мы имеем дело, это не влияет на работоспособность кода, однако помогает читать код:
    ```Python
        count: int = 8
        name: str = "Bob"
        size: float = 12.5
        is_active: bool = True
    ```
